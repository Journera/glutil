#!/usr/bin/env python3

import argparse

# this is so this script can import from the lib directory
import os
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from glutil import DatabaseCleaner, GlutilError
from glutil.utils import print_batch_errors

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""
Delete bad tables.

What is a bad table?

1.  Any table that exists in a location _under_ another table.
    For example, if one table is located in
        s3://some-bucket/some-directory/
    and another table is found located in
        s3://some-bucket/some-directory/another-directory/
    the second table (another-directory) will be deleted.

2.  When two tables exist in the same location, and one is named after the
    location, while the other is named location_somerandomcharacters, the second
    is considered bad and deleted.

Most of the time, these tables are created by the glue crawler doing something
we didn't want or expect.
"""
    )
    parser.add_argument(
        "database",
        type=str,
        help="athena database, most likely staging or production")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Perform a \"dry-run\", show the actions to be taken without actually performing them.")
    parser.add_argument("--profile", "-p", type=str, help="AWS profile to use")
    args = parser.parse_args()

    try:
        cleaner = DatabaseCleaner(args.database, aws_profile=args.profile)
        to_delete = cleaner.child_tables()
    except GlutilError as e:
        print("Error:", e.message)
        sys.exit(1)

    if not to_delete:
        print("Nothing to delete")
    else:
        print("Going to delete the following tables:")
        for table in to_delete:
            print(table)

        if not args.dry_run:
            errors = cleaner.delete_tables(to_delete)
            if errors:
                print_batch_errors(errors)
