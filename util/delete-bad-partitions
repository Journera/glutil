#!/usr/bin/env python3

import argparse

# this is so this script can import from the lib directory
import os
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from glutil.utils import print_batch_errors
from glutil import Partitioner, GlutilError


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""
Delete "bad" partitions in a table.

"Bad" partitions are those where the S3 location does not match the expected
location. This can happen for a variety of reasons, with the most common being
moving the backing data to a new S3 location.

For example, if your table has the location of
    s3://some-bucket/some-table/

And you have a partition with the location of
    s3://some-other-bucket/who-knows/YYYY/MM/DD/HH/

This script will delete that partition.

It will also delete partitions who's S3 location values do not match its
partition values (for example, a if a partition has the values
[2019, 01, 01, 01], but is located in s3://some-bucket/table/2019/02/02/02/).

After running this you should run the partitioner again to pick up the correct
location of any deleted partitions.
"""
    )
    parser.add_argument(
        "database",
        type=str,
        default="",
        help="The Athena/Glue database containing the table you want to search for partitions")
    parser.add_argument(
        "table",
        type=str,
        help="The Athena/Glue table you want to search for partitions")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Perform a \"dry-run\", show the actions to be taken without actually performing them.")
    parser.add_argument("--profile", "-p", type=str, help="AWS profile to use")
    args = parser.parse_args()

    try:
        partitioner = Partitioner(args.database, args.table, args.profile)
    except GlutilError as e:
        print("Error:", e.message)
        sys.exit(1)

    to_delete = partitioner.bad_partitions()
    print("found {} partitions to delete".format(len(to_delete)))

    if not args.dry_run:
        errors = partitioner.delete_partitions(to_delete)
        if errors:
            print_batch_errors(errors)
